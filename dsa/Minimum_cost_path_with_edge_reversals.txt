// Date: 27/01/2026
// Problem: https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/

import java.lang.*;
import java.util.*;

class Node implements Comparable<Node> {

  int v;
  int wt;

  Node(int v, int wt) {
    this.v = v;
    this.wt = wt;
  }

  @Override
  public int compareTo(Node other) {
    if (this.v == other.v) {
      return Integer.compare(this.wt, other.wt);
    }
    return Integer.compare(this.v, other.v);
  }
}

class Main {

  static final int INF = Integer.MAX_VALUE;

  public static void main(String[] args) {
    int[][] edges = { { 0, 1, 3 }, { 3, 1, 1 }, { 2, 3, 4 }, { 0, 2, 2 } };
    int n = 4;

    int res = minCost(n, edges);

    System.out.println(res);
  }

  static int minCost(int n, int[][] edges) {
    List<List<Node>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      graph.add(new ArrayList<>());
    }

    int[] distances = new int[n];
    Arrays.fill(distances, INF);

    for (int[] edge : edges) {
      int u = edge[0];
      int v = edge[1];
      int wt = edge[2];

      // Direct edge cost is wt, reverse edge cost is 2*wt
      graph.get(u).add(new Node(v, wt));
      graph.get(v).add(new Node(u, 2 * wt));
    }

    // Standard Dijkstra's to find min cost
    PriorityQueue<Node> pq = new PriorityQueue<>();
    pq.offer(new Node(0, 0));

    while (!pq.isEmpty()) {
      Node curr = pq.poll();
      int u = curr.v;
      int cost = curr.wt;

      if (cost > distances[u]) continue;

      for (Node node : graph.get(u)) {
        if (distances[node.v] > cost + node.wt) {
          distances[node.v] = cost + node.wt;
          pq.offer(new Node(node.v, distances[node.v]));
        }
      }
    }

    return distances[n - 1] == INF ? -1 : distances[n - 1];
  }
}
