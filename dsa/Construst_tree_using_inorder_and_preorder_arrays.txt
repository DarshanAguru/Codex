// Date: 19/08/2025
// Problem: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
// Leetcode Problem No: 105
// Relevance: Tree, Array, Hash Table, Divide and Conquer

import java.lang.*;
import java.util.*;

class Node {

  public Node left, right;
  public int val;

  Node(int val) {
    this.val = val;
  }
}

class Main {

  public static void main(String[] args) {
    int[] inorder = { 40, 20, 50, 10, 60, 30 };
    int[] preorder = { 10, 20, 40, 50, 30, 60 };

    Node root = constructTree(inorder, preorder);
    printInorder(root);
  }

  static void printInorder(Node root) {
    if (root == null) return;
    printInorder(root.left);
    System.out.print(root.val + " ");
    printInorder(root.right);
  }

  static Node constructTree(int[] inorder, int[] preorder) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
      map.put(inorder[i], i);
    }
    return build(
      preorder,
      0,
      preorder.length - 1,
      inorder,
      0,
      inorder.length - 1,
      map
    );
  }

  static Node build(
    int[] preorder,
    int preStart,
    int preEnd,
    int[] inorder,
    int inStart,
    int inEnd,
    Map<Integer, Integer> map
  ) {
    if (preStart > preEnd || inStart > inEnd) return null;

    Node root = new Node(preorder[preStart]);

    int inRoot = map.get(root.val);
    int numsLeft = inRoot - inStart;

    root.left = build(
      preorder,
      preStart + 1,
      preStart + numsLeft,
      inorder,
      inStart,
      inRoot - 1,
      map
    );

    root.right = build(
      preorder,
      preStart + numsLeft + 1,
      preEnd,
      inorder,
      inRoot + 1,
      inEnd,
      map
    );

    return root;
  }
}
