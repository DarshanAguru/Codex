// Date: 18/08/2025
// Problem: https://practice.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1
// Leetcode Problem No: 987 (Related: Vertical Order Traversal)
// Relevance: Tree, BFS, Hash Table

import java.lang.*;
import java.util.*;

class Node {

  public Node left, right;
  public int val;

  Node(int val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

class Pair {

  Node node;
  int hd; // horizontal distance

  Pair(Node node, int hd) {
    this.node = node;
    this.hd = hd;
  }
}

class Main {

  public static void main(String[] args) {
    Node root = new Node(1);
    root.left = new Node(2);
    root.left.left = new Node(4);
    root.left.left.right = new Node(5);
    root.left.left.right.right = new Node(6);
    root.left.right = new Node(10);
    root.right = new Node(3);
    root.right.left = new Node(9);
    root.right.right = new Node(11);

    List<Integer> res = getBottomViewOfTree(root);
    System.out.println(res);
  }

  // Method to compute the Bottom View of a Binary Tree
  // Bottom View consists of the nodes visible from the bottom (i.e., last node at each horizontal distance)
  static List<Integer> getBottomViewOfTree(Node root) {
    if (root == null) return new ArrayList<>();

    // Map to store Horizontal Distance (HD) -> Node Value
    // We use a TreeMap to keep the keys (HD) sorted from left to right (-ve to +ve)
    Map<Integer, Integer> map = new TreeMap<>();

    // BFS Queue storing Node and its Horizontal Distance
    Queue<Pair> q = new LinkedList<>();

    q.add(new Pair(root, 0));

    while (!q.isEmpty()) {
      Pair p = q.poll();
      Node node = p.node;
      int hd = p.hd;

      // Update the map for this HD. Since we are doing BFS (level order),
      // the last node processed for a given HD will be the "bottom-most" one.
      map.put(hd, node.val);

      if (node.left != null) {
        q.add(new Pair(node.left, hd - 1));
      }
      if (node.right != null) {
        q.add(new Pair(node.right, hd + 1));
      }
    }

    return new ArrayList<>(map.values());
  }
}
