// Date: 09/02/2026
// Problem: https://leetcode.com/problems/balance-a-binary-search-tree/
// Leetcode Problem No: 1382
// Relevance: Divide and Conquer, Binary Search Tree, Greedy, Tree, Binary Tree, Depth-First Search

import java.lang.*;
import java.util.*;

class TreeNode {

  int val;
  TreeNode left;
  TreeNode right;

  TreeNode() {}

  TreeNode(int val) {
    this.val = val;
  }

  TreeNode(int val, TreeNode left, TreeNode right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

class Main {

  public static void main(String[] args) {
    TreeNode root = new TreeNode(1);
    root.right = new TreeNode(2);
    root.right.right = new TreeNode(3);
    root.right.right.right = new TreeNode(4);

    TreeNode result = balanceBST(root);
    System.out.println(result.val);
  }

  public static TreeNode balanceBST(TreeNode root) {
    List<Integer> sortedList = new ArrayList<>();
    populateListFromBST(root, sortedList);
    return constructBalancedBST(sortedList, 0, sortedList.size() - 1);
  }

  private static TreeNode constructBalancedBST(
    List<Integer> sortedList,
    int l,
    int h
  ) {
    if (l > h) return null;
    int m = l + (h - l) / 2;
    TreeNode left = constructBalancedBST(sortedList, l, m - 1);
    TreeNode right = constructBalancedBST(sortedList, m + 1, h);
    return new TreeNode(sortedList.get(m), left, right);
  }

  private static void populateListFromBST(TreeNode root, List<Integer> list) {
    if (root == null) {
      return;
    }
    populateListFromBST(root.left, list);
    list.add(root.val);
    populateListFromBST(root.right, list);
  }
}
