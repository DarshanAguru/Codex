// Date: 18/08/2025
// Problem: https://leetcode.com/problems/largest-rectangle-in-histogram/
// Leetcode Problem No: 84
// Relevance: Stack

import java.lang.*;
import java.util.*;

class Main {

  public static void main(String[] args) {
    int[] heights = { 2, 1, 5, 6, 2, 3 };

    int res = getAreaOfLargestRect(heights);
    System.out.println(res);
  }

  static int getAreaOfLargestRect(int[] heights) {
    int n = heights.length;
    // Monotonic Stack (Increasing order of heights)
    // Stores indices. Used to find the "Nearest Smaller Element" on left and right.
    Stack<Integer> st = new Stack<>();
    int maxArea = 0;

    // Iterate through all bars. Note: i goes up to n (inclusive)
    // We treat i=n as a bar with height 0 to force clearing the stack at the end.
    for (int i = 0; i <= n; i++) {
      // Current height is 0 if we reached the end, else heights[i]
      int curH = (i == n) ? 0 : heights[i];

      // While stack is not empty and current bar is smaller than the bar at stack top
      // It means 'i' is the Right Boundary (first smaller element on right) for st.peek()
      while (!st.isEmpty() && curH < heights[st.peek()]) {
        // Pop the bar that cannot extend further right
        int h = heights[st.pop()];

        // Determine Left Boundary (first smaller element on left)
        // If stack is empty, it means 'h' was the smallest so far, so it extends to index 0.
        // Else, the new top of stack is the left boundary.
        int width;
        if (st.isEmpty()) {
          width = i; // Width = Right Boundary - 0
        } else {
          width = i - st.peek() - 1; // Width = Right Boundary - Left Boundary - 1
        }

        maxArea = Math.max(maxArea, width * h);
      }
      st.push(i);
    }
    return maxArea;
  }
}
